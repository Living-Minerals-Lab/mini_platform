from custom_interfaces import action
import rclpy
import rclpy.action
import rclpy.callback_groups
import rclpy.parameter
import threading
import time
import abc

class RealServer(metaclass=abc.ABCMeta):
    """
    ABC for a generic action server that can be subclassed to quickly create action
    servers of varying types.

    Args:
        node_name (:obj:`str`): name to use for the node (e.g. docking_controller)
        action_name (:obj:`str`): name of the action server (e.g. dock)
        action_type (:obj:`any`): type of the action server (e.g. py_trees_ros_interfaces.Dock
    """
    def __init__(self,
                 node_name,
                 action_name,
                 action_type,  # e.g. py_trees_ros_interfaces.action.Dock
                 ):
        self.node = rclpy.create_node(
            node_name,
        )

        self.goal_handle = None
        self.goal_lock = threading.Lock()

        self.action_type = action_type

        self.goal_handle = None

        self.action_server = rclpy.action.ActionServer(
            node=self.node,
            action_type=self.action_type,
            action_name=action_name,
            callback_group=rclpy.callback_groups.ReentrantCallbackGroup(),  # needed?
            cancel_callback=self.cancel_callback,
            execute_callback=self.execute_goal_callback,
            goal_callback=self.goal_callback,
            handle_accepted_callback=self.handle_accepted_callback,
            result_timeout=10
        )

    ################################################################
    # Methods for generating success, pre-empted and aborted resutls
    # Empty results will be generated by default
    ################################################################

    def generate_success_result(self):
        return self.action_type.Result()
    
    def generate_preempted_result(self):
        return self.action_type.Result()
    
    def generate_cancelled_result(self):
        return self.action_type.Result()
    
    ################################################################
    # Methods for generating feedback message
    # Empty feedback will be generated by default
    ################################################################
    def generate_feedback_message(self):
        return self.action_type.Feedback()

    ################################################################
    # ROS action server callback functions
    ################################################################

    def goal_callback(self, goal_request):
        """
        Accept all goals by default
        Args:
            goal_request: of <action_type>.GoalRequest with members
                goal_id (unique_identifier.msgs.UUID) and those specified in the action
        """
        self.node.get_logger().info("received a goal")
        return rclpy.action.server.GoalResponse.ACCEPT

    def cancel_callback(
            self,
            goal_handle: rclpy.action.server.ServerGoalHandle
         ) -> rclpy.action.CancelResponse:
        """
        Accept all cancel requests by default.

        Args:
            cancel_request (:class:`~rclpy.action.server.ServerGoalHandle`):
                handle with information about the
                goal that is requested to be cancelled
        """
        self.node.get_logger().info("cancel requested: [{goal_id}]".format(
            goal_id=goal_handle.goal_id))
        return rclpy.action.CancelResponse.ACCEPT

    @abc.abstractmethod
    def execute_goal_callback(
            self,
            goal_handle: rclpy.action.server.ServerGoalHandle
         ):
        """
        Callback function for executing accepted goals.
        This is the main callback that needs to be overridden. 

        Args:
            goal_handle (:class:`~rclpy.action.server.ServerGoalHandle`): the goal handle of the executing action
        """
        # goal.details (e.g. pose) = don't care
        self.node.get_logger().info("executing a goal")
        
        # Functions for hardware to take actions should be called below.
        

        # It takes time for hardware complete actions.
        # Therefor we need a while loop so that different result status and content can be returned. 
        # Below is a simple example when the action takes a fixed time.
        freq = 1 # hz
        action_duration = 10 # sec
        start_time = time.time() 
        
        while True:
            time.sleep(1.0 / freq)
            percent_completed = 100 * (time.time() - start_time) / action_duration
            with self.goal_lock:
                if goal_handle.is_active:
                    if goal_handle.is_cancel_requested:
                        result = self.generate_cancelled_result()
                        message = "goal cancelled at {percentage:.2f}%%".format(
                            percentage=percent_completed)
                        self.node.get_logger().info(message)
                        goal_handle.canceled()
                        return result
                    elif goal_handle.goal_id != self.goal_handle.goal_id:
                        result = self.generate_preempted_result()
                        message = "goal pre-empted at {percentage:.2f}%%".format(
                            percentage=percent_completed)
                        self.node.get_logger().info(message)
                        goal_handle.abort()
                        return result
                    elif percent_completed >= 100.0:
                        percent_completed = 100.0
                        self.node.get_logger().info("sending feedback 100%%")
                        result = self.generate_success_result()
                        message = "goal executed with success"
                        self.node.get_logger().info(message)
                        goal_handle.succeed()
                        return result
                    else:
                        self.node.get_logger().info("sending feedback {percentage:.2f}%%".format(
                            percentage=percent_completed))
                        goal_handle.publish_feedback(
                            self.generate_feedback_message()
                        )
                else:  # ! active
                    self.node.get_logger().info("goal is no longer active, aborting")
                    result = self.action_type.Result()
                    return result

    def handle_accepted_callback(self, goal_handle):
        """Execute all accepted goals by default.

        Args:
            goal_handle (:class:`~rclpy.action.server.ServerGoalHandle`): the goal handle of the executing action
        """
        self.node.get_logger().info("handle accepted")
        with self.goal_lock:
            self.goal_handle = goal_handle
            goal_handle.execute()

    def abort(self):
        """
        This method is typically only used when the system is shutting down and
        there is an executing goal that needs to be abruptly terminated.
        """
        with self.goal_lock:
            if self.goal_handle and self.goal_handle.is_active:
                self.node.get_logger().info("aborting...")
                self.goal_handle.abort()

    def shutdown(self):
        """
        Cleanup
        """
        self.action_server.destroy()
        self.node.destroy_node()